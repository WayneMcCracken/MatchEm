package  {		import flash.display.MovieClip;	import flash.display.Loader;	import flash.net.URLRequest;	import flash.events.MouseEvent;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.text.*;	import flash.events.Event;		public class Game extends MovieClip {				private static const VERSION_UID: String = "V1.00";				private var Stats: String = "CLX:" + clx + " Ms:" + mc + " Evs:" + ec;		public var clx: uint = 0; //Clicks preformed, how many times the player clicked a tile.		public var tuc: uint = 0; //Text Update Counter, to keep track of text refreshes.		public var mc: uint = 0; //Match Counter, keeps track of total matches.		public var ec: uint = 0; //Evolution Counter, keeps track of total evolutions.				private static const NUMBER_OF_TILES: uint = 35;		private static const TILES_PER_ROW: uint = 5;		private static const DEFAULT_TILE: uint = 13;		private static const FIRE_TILE: uint = 14;		private static const GRASS_TILE: uint = 15;		private static const WATER_TILE: uint = 16; 		private static const LIGHTNING_TILE: uint = 17;				public var remainingTiles: uint = 35; 		public var tileContainer: MovieClip = new MovieClip();		public var tiles: Array = new Array();			public var tile: Tile;		public var timeUnit: TimingUnit = new TimingUnit(540, 20);		public var pickedTiles: Array = new Array();		public var pauseGame: Timer = new Timer(0, 1);		public var pickable: Boolean = true;		public var psyduckOnline: Boolean = false;		private var startClip: GameStartClip = new GameStartClip();		public var points: uint = 0;		public var endScreen: EndScreen;		public var bg: Background = new Background();				//TEXT BOX VARIABLES		public var mainTextBox: TextBox;		public var secondTextBox: TextBox;		public var thirdTextBox: TextBox;		public var statsTextBox: TextBox;		public var versionTextBox: TextBox = new TextBox(VERSION_UID, 610, 10, 25, 25);		public var pointsTextBox: TextBox;				public var currentMessage: String = "Welcome to Match Em'!\n Select a tile.";		public var previousMessage: String = "< >";		public var lastPreviousMessage: String = "< >";		public var nextMessage: String = "";				public var mainTextFormat: TextFormat;		public var previousTextFormat: TextFormat;		public var statsTextFormat: TextFormat = new TextFormat("Courier", 10, 0x000000); //Global access, because it's used for multiple boxes.		public var pointsTextFormat;				public var final_P_TextBox: TextBox;		public var final_E_TextBox: TextBox;		public var final_M_TextBox: TextBox;		public var final_C_TextBox: TextBox;		public var finalTextFormat: TextFormat;				//Constructor		public function Game() {			trace("Welcome to Match Em'");			addChild(bg);			generateTiles();			shuffleTiles();			drawTiles();			drawTextBoxes();			drawPoints();		}				public function generateTiles(): void {			for (var i: uint = 0; i < NUMBER_OF_TILES; i++){				tiles.push(Math.floor( i / 3));			}			trace("The generated tiles are: " + tiles);		}				public function shuffleTiles(): void {			var swap: uint;			var temp: uint;			for (var i: uint = NUMBER_OF_TILES - 1; i > 0; i--){				swap = Math.floor(Math.random() * i);				temp = tiles[i];				tiles[i] = tiles[swap];				tiles[swap] = temp;			}			trace("The tiles are shuffled, they are: " + tiles);		}				public function drawTiles(): void {			//logic for version id			var tileID: uint = 0;			versionTextBox.setTextFormat(statsTextFormat);			versionTextBox.addEventListener(Event.ADDED_TO_STAGE, drawStartClip);			addChild(versionTextBox);			//Draw 35 tiles to the stage.			for (var i: uint = 0; i < NUMBER_OF_TILES; i++) {				tileID++;				tile = new Tile(tileID);				tileContainer.addChild(tile);				tile.cardType = tiles[i];				trace("This tiles name is " + tile.name);				tile.x = 4.5 + (tile.width + 6.5) * (i % TILES_PER_ROW);				tile.y = 7 + (tile.height + 8.5) * (Math.floor(i / TILES_PER_ROW));				tile.currX = tile.x;				tile.currY = tile.y;				trace("X"+ tile.currX + "\n" + "Y" + tile.currY);				tile.gotoAndStop(DEFAULT_TILE);				tile.buttonMode = true;				tile.addEventListener(MouseEvent.CLICK, onTileClicked);							}						addChild(tileContainer);			trace("Drawing Complete");		}				private function clearTiles(): void {			while (tileContainer.numChildren > 1) { 				tileContainer.removeChildAt(tileContainer.numChildren - 1);			}		}				private function revealTiles(): void {			if (psyduckOnline == true) {				var index: uint = 0;				for (var i: uint = 0; i < remainingTiles; i++) {										tile = tileContainer.getChildAt(index) as Tile;									if (tile.cardType == 1 || tile.cardType == 2 || tile.cardType == 3) { tile.gotoAndStop(FIRE_TILE); }					else if (tile.cardType == 4 || tile.cardType == 5 || tile.cardType == 6) { tile.gotoAndStop(GRASS_TILE); }					else if (tile.cardType == 7 || tile.cardType == 8 || tile.cardType == 9) { tile.gotoAndStop(WATER_TILE); }					else if (tile.cardType ==  10 || tile.cardType == 0) { tile.gotoAndStop(LIGHTNING_TILE); }					index++;				}			}		}				private function onTileClicked(e: MouseEvent): void {			if  (pickable) {			updateClicksCounter()			var picked: Tile = e.currentTarget as Tile;			var pickingText: String = "You picked " + e.currentTarget.toName(e.currentTarget.cardType) + ".";			trace(pickingText);			nextMessage = pickingText; 			replaceText();			if (e.currentTarget.cardType == 11) { e.currentTarget.gotoAndStop (12); 			if (e.currentTarget == pickedTiles[0]) {				nextMessage = "Please select a second tile."				replaceText();				} }			else if (e.currentTarget.cardType == 0) { e.currentTarget.gotoAndStop(11);			if (e.currentTarget == pickedTiles[0]) {				nextMessage = "Please select a second tile."				replaceText();				} }			else if (e.currentTarget == pickedTiles[0]) {				trace("Please pick a second tile.");				nextMessage = "Please select a second tile."				replaceText();				}			else {			e.currentTarget.gotoAndStop(e.currentTarget.cardType); }			//Check if the tile has already been picked.			if (pickedTiles.indexOf(picked) == -1) {				pickedTiles.push(picked);				//picked.gotoAndStop(picked.cardType);			}			checkArrayLength();			}		}				private function destroyTiles(e: TimerEvent): void {			pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);			pickedTiles[0].removeEventListener(MouseEvent.CLICK, onTileClicked);			pickedTiles[1].removeEventListener(MouseEvent.CLICK, onTileClicked);			tileContainer.removeChild(pickedTiles[0]);			tileContainer.removeChild(pickedTiles[1]);			if (pickedTiles.length == 3) {			pickedTiles[2].removeEventListener(MouseEvent.CLICK, onTileClicked);			tileContainer.removeChild(pickedTiles[2]); }			remainingTiles = tiles.length - pickedTiles.length;			trace(remainingTiles);			tiles.length = remainingTiles;			pickedTiles = new Array();			pickable = true;			if (remainingTiles == 0) { trace ("Game Over Reached!"); endGame(); }		}				private function resetTiles(e: TimerEvent): void {			pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, resetTiles);			if (stage.contains(timeUnit)) { stage.removeChild(timeUnit); 			nextMessage = "Evolution fail!";			replaceText();			}			pickedTiles[0].gotoAndStop(DEFAULT_TILE);			pickedTiles[1].gotoAndStop(DEFAULT_TILE);			if (pickedTiles.length == 3) {			pickedTiles[2].gotoAndStop(DEFAULT_TILE);			} 			if (psyduckOnline == true) { revealTiles(); }			pickedTiles = new Array();			pickable = true;		}				public function drawTextBoxes(): void {			//Draw the primary text box			mainTextBox = new TextBox(currentMessage, 495, 345, 135, 100);			mainTextFormat = new TextFormat("Times New Roman", 24, 0x000000);			mainTextFormat.align = TextFormatAlign.CENTER;			mainTextBox.setTextFormat(mainTextFormat);			addChild(mainTextBox);			//finish drawing the primary text box						//Draw the secondary text box			secondTextBox = new TextBox(previousMessage, 510, 280, 100, 50);			previousTextFormat = new TextFormat("Times New Roman", 16, 0x000000);			previousTextFormat.align = TextFormatAlign.CENTER;			secondTextBox.setTextFormat(previousTextFormat);			addChild(secondTextBox);			//finish drawing the second box						//Draw the third box			thirdTextBox = new TextBox(lastPreviousMessage, 510, 220, 100, 50);			thirdTextBox.setTextFormat(previousTextFormat);			addChild(thirdTextBox);			//finish drawing the third box						//Draw stats text box.			statsTextBox = new TextBox(Stats, 500, 455, 160	, 15);			statsTextFormat.align = TextFormatAlign.LEFT;			statsTextBox.setTextFormat(statsTextFormat);			addChild(statsTextBox);			//finish drawing stats.		}				private function drawPoints(): void {			pointsTextBox = new TextBox("SCORE: \n" + points, 522, 165, 100, 100);			pointsTextFormat = new TextFormat("Courier", 20, 0x000000);			pointsTextBox.setTextFormat(pointsTextFormat);			addChild(pointsTextBox);		}				private function checkForMatch(): void {			pauseGame.delay = 1000;			var matchText: String			trace("Now checking for match.");			if (pickedTiles[0].cardType == pickedTiles[1].cardType) {				if (pickedTiles[0].cardType == 11 && pickedTiles[1].cardType == 11) {					updateMatchCounter();					updatePoints(1000);					pickable = false;					matchText = "Psychic powers unlocked.";					trace(matchText);					nextMessage = matchText;					replaceText();					psyduckWorks();					pauseGame.start();					pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);				} else {					updateMatchCounter();					updatePoints(400)					pickable = false;					matchText = "You have a match!\n400 Points";					trace(matchText);					nextMessage = matchText; 					replaceText();					pauseGame.start();					pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);				}			} else if (pickedTiles[0].cardType == 1 && pickedTiles[1].cardType == 2) {				pushEvolution();			} else if (pickedTiles[0].cardType == 4 && pickedTiles[1].cardType == 5) {				pushEvolution();			} else if (pickedTiles[0].cardType == 7 && pickedTiles[1].cardType == 8) {				pushEvolution();			} else if (pickedTiles[0].cardType == 10 && pickedTiles[1].cardType == 0) {				checkForEvolution();			} else {				pickable = false; 				matchText = "No Match\nfor you!";				trace(matchText);				nextMessage = matchText;				replaceText();				pauseGame.start();				pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, resetTiles);			}		}				private function replaceText(): void {			removeChild(mainTextBox);			removeChild(secondTextBox);			removeChild(thirdTextBox);			removeChild(statsTextBox);			updateTUC();			lastPreviousMessage = previousMessage;			previousMessage = currentMessage;			currentMessage = nextMessage;			drawTextBoxes();					}				private function pushEvolution(): void {				if (pickedTiles[0].cardType == 1 && pickedTiles[1].cardType == 2 ||					pickedTiles[0].cardType == 4 && pickedTiles[1].cardType == 5 ||					pickedTiles[0].cardType == 7 && pickedTiles[1].cardType == 8)				{				trace("pushing for evolution");				pauseGame.delay = 5000;				pauseGame.start();				stage.addChild(timeUnit);				timeUnit.gotoAndPlay(1);				pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, resetTiles);				stage.addEventListener(MouseEvent.CLICK, onThirdClick);				} else return;		}				private function checkForEvolution(): void {			trace("Checking for evolution");			pauseGame.stop();			pauseGame.delay = 1000;			var evolutionText: String;						//LIGHTNING EVOLUTION CHECK			if (pickedTiles[0].cardType == 10 && pickedTiles[1].cardType == 0) {					evolutionText = "Lightning Evolution!\n600 Points.";					updatePoints(600)					updateEvolutionCounter();					nextMessage = evolutionText; 					replaceText();					trace(evolutionText);					pickable = false;					pauseGame.start();					pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);					return;				}							//FIRE EVOLUTION CHECK			if (pickedTiles[0].cardType == 1 && pickedTiles[1].cardType == 2 && pickedTiles[2].cardType == 3) {								evolutionText = "Fire Evolution!\n800 Points.";				updatePoints(800)				updateEvolutionCounter();				nextMessage = evolutionText; 				replaceText();				trace(evolutionText);								pickable = false;				//cleanup logic				if (stage.contains(timeUnit)) { stage.removeChild(timeUnit); }				pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, resetTiles);				pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);								pauseGame.start();				pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);				return;			}						//GRASS EVOLUTION CHECK			if (pickedTiles[0].cardType == 4 && pickedTiles[1].cardType == 5 && pickedTiles[2].cardType == 6) {								evolutionText = "Grass Evolution!\n800 Points.";				updatePoints(800)				updateEvolutionCounter();				nextMessage = evolutionText; 				replaceText();				trace(evolutionText);								pickable = false;				//cleanup logic				if (stage.contains(timeUnit)) { stage.removeChild(timeUnit); }				pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, resetTiles);				pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);								pauseGame.start();				pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);				return;			}						//WATER EVOLUTION CHECK			if (pickedTiles[0].cardType == 7 && pickedTiles[1].cardType == 8 && pickedTiles[2].cardType == 9) {								evolutionText = "Water Evolution!\n800 Points.";				updatePoints(800);				updateEvolutionCounter();				nextMessage = evolutionText; 				replaceText();				trace(evolutionText);								pickable = false;				//cleanup logic				if (stage.contains(timeUnit)) { stage.removeChild(timeUnit); }				pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, resetTiles);				pauseGame.removeEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);								pauseGame.start();				pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, destroyTiles);				return;			}			else {				pickable = false;				pauseGame.start();				pauseGame.addEventListener(TimerEvent.TIMER_COMPLETE, resetTiles);			}		}				private function psyduckWorks(): void {			trace(tiles);			trace("The total number of tiles is: " + (remainingTiles - 2));			psyduckOnline = true;			revealTiles();		}				private function updateTUC(): void {			Stats = "";			tuc++;			trace("tuc is " + tuc);			Stats = "CLX:" + clx + " Ms:" + mc + " Evs:" + ec;		}				private function updateMatchCounter(): void {			Stats = "";			mc++;			trace("mc is " + mc);			Stats = "CLX:" + clx + " Ms:" + mc + " Evs:" + ec;		}				private function updateEvolutionCounter(): void {			Stats = "";			ec++;			trace("ec is " + ec);			Stats = "CLX:" + clx + " Ms:" + mc + " Evs:" + ec;		}				private function updateClicksCounter(): void {			Stats = "";			clx++;			trace("clx is " + clx);			if (clx >= 1000) { Stats = "CLX:1K+" + " Ms:" + mc + " Evs:" + ec; }			Stats = "CLX:" + clx + " Ms:" + mc + " Evs:" + ec;		}				private function updatePoints(amount: uint): void {			points += amount;			removeChild(pointsTextBox);			drawPoints();		}				public function checkArrayLength(): void {			if (pickedTiles.length == 2) {				checkForMatch();				}			if (pickedTiles.length == 3) {				checkForEvolution();			}		}				private function onThirdClick(e: MouseEvent): void {			if (pickedTiles.length == 2) { 			stage.removeEventListener(MouseEvent.CLICK, onThirdClick);			var pickPrompt: String =  "Please select a third tile.";			trace(pickPrompt);			nextMessage = pickPrompt; 			replaceText();			//pushEvolution(); Call back that is no longer needed?			}			else {				stage.removeEventListener(MouseEvent.CLICK, onThirdClick);				checkArrayLength();			}		}				private function drawStartClip(e: Event): void {			addChild(startClip);			versionTextBox.removeEventListener(Event.ADDED_TO_STAGE, drawStartClip);			startClip.addEventListener(Event.ENTER_FRAME, onUpdatingStartClip);		}				private function onUpdatingStartClip(e: Event): void {						 if(startClip.currentFrame == 24) {				startClip.removeEventListener(Event.ENTER_FRAME, onUpdatingStartClip);				removeChild(startClip);			}		}				private function endGame(): void {			endScreen = new EndScreen();			if (points == 10000) endScreen.gotoAndStop(2);			else endScreen.gotoAndStop(1);			finalTextFormat = new TextFormat("_sans", 24, 0xFFFFFF, true);			final_P_TextBox = new TextBox(String(points), 160, 230, 100, 50);			final_P_TextBox.setTextFormat(finalTextFormat);			final_E_TextBox = new TextBox(String(ec), 225, 280, 50, 50);			final_E_TextBox.setTextFormat(finalTextFormat);			final_M_TextBox = new TextBox(String(mc), 200, 305, 50, 50);			final_M_TextBox.setTextFormat(finalTextFormat);			final_C_TextBox = new TextBox(String(clx), 230, 330, 50, 50);			final_C_TextBox.setTextFormat(finalTextFormat);						addChild(endScreen);			addChild(final_P_TextBox);			addChild(final_E_TextBox);			addChild(final_M_TextBox);			addChild(final_C_TextBox);						dispatchEvent(new Event("GameEnded"));					}	}}